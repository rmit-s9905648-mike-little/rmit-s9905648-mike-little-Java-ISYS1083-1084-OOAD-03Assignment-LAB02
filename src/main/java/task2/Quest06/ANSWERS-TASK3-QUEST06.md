## QUESTION06


In a graphical user diagramming application such as Corel Draw, Photoshop, or OmniGraffle, typically there is a three tier model, in which the upper tier consist of a user interface layer, a domain layer, and a date layer, which these days is represented as the view, controller, and model. With this representation, user interface events such as OnClicking a button, or onDragging an object is recognized in the user interface layer, and the action of the user interface event his hand to the Control logic that is handled in the domain layer objects, that retreat or stores Data or information in the model, Data layer.  This architectural approach is best handled by the command design pattern, which is behavioral design pattern that takes a request made by a user interface event action and passes it to an object that contains all the information to handle the request, that then further manages the data associated with the request.
In addition, a key aspect of editor applications, whether they be practical or textual, is the ability to undo a change, or redo (Restore) a change.’ The best approach to attain this capability is to use the memento design pattern. With this it captures the state of an object at a particular instance by serializing the object [ using as “**java.io.Serializable**” ]  so that it can be restored in the future

Consider a graphical editor that allows the changing and position of shapes in a drawing package. Being an editor, changes may need to be undone, or repeated. As a result the graphical editor in the diagramming application may need to maintain a history of the performed actions by the user of the graphical editor component. As a result before executing a command function, the graphical editor Will make a back up of all the objects and connected it, or associate it with a command object. After execution of the command function that the user of the graphical editor has chosen the graphical editor Will remember the executed command function by pushing it onto the history stack. As a result, is the user of the graphical editor then chooses to perform and undo function, the editor will fetch the most recent command from the history stack, and then restore the state of the object from the back up.
Is the user of the graphical editor application again request another undo operation, then the editor of the practical editor application shall take the following command from the history stack and then restore the respective state of the object that is associated with it etc.. At the same time the graphical editor application shall also keep commands in the history stack that have been reverted to the prior state, does allowing the user of the graphical editor application the capability to redo particular command operation.




<br /><br />